// Query generator for kintone fields

// フィールドマッピング設定
interface FieldMapping {
  factory: string;
  hasOptions?: boolean;
}

const FIELD_TYPE_MAPPINGS: Record<string, FieldMapping> = {
  // Text fields
  SINGLE_LINE_TEXT: { factory: 'createStringField' },
  MULTI_LINE_TEXT: { factory: 'createStringField' },
  RICH_TEXT: { factory: 'createStringField' },
  LINK: { factory: 'createStringField' },

  // Number fields
  NUMBER: { factory: 'createNumberField' },
  CALC: { factory: 'createNumberField' },

  // Selection fields with options
  DROP_DOWN: { factory: 'createDropdownField', hasOptions: true },
  CHECK_BOX: { factory: 'createCheckboxField', hasOptions: true },
  MULTI_SELECT: { factory: 'createCheckboxField', hasOptions: true },
  RADIO_BUTTON: { factory: 'createRadioButtonField', hasOptions: true },

  // Date/Time fields
  DATE: { factory: 'createDateField' },
  TIME: { factory: 'createTimeField' },
  DATETIME: { factory: 'createDateTimeField' },

  // User/Organization fields
  USER_SELECT: { factory: 'createUserField' },
  ORGANIZATION_SELECT: { factory: 'createOrgField' },
  GROUP_SELECT: { factory: 'createGroupField' },
};

// Unsupported field types for queries
const UNSUPPORTED_FIELD_TYPES = new Set([
  'SUBTABLE',
  'FILE',
  'CATEGORY',
  'STATUS',
  'STATUS_ASSIGNEE',
  'CREATED_TIME',
  'UPDATED_TIME',
  'CREATOR',
  'MODIFIER',
  'RECORD_NUMBER',
  'HR',
  'GROUP',
  'SPACER',
  'LABEL',
  'REFERENCE_TABLE',
]);

// フィールドタイプマッピング取得
const getFieldMapping = (type: string): FieldMapping | null => {
  if (UNSUPPORTED_FIELD_TYPES.has(type)) {
    return null;
  }
  return FIELD_TYPE_MAPPINGS[type] || null;
};

// クエリビルダーコード生成
export const generateQueryBuilder = (
  formFields: any,
  appName: string
): string => {
  const fields = formFields.properties || {};
  const fieldDefinitions: string[] = [];
  const imports = new Set<string>();
  const warnings: string[] = [];
  let hasDateFields = false;

  // フィールドごとの処理
  Object.entries(fields).forEach(([code, field]: [string, any]) => {
    const mapping = getFieldMapping(field.type);

    if (!mapping) {
      // クエリで使用できないフィールドの場合、開発者向けコメントを追加
      if (!UNSUPPORTED_FIELD_TYPES.has(field.type)) {
        warnings.push(
          `  // Warning: Unknown field type '${field.type}' for field '${code}'`
        );
      }
      return;
    }

    imports.add(mapping.factory);

    // Date系フィールドのチェック
    if (['DATE', 'DATETIME', 'TIME'].includes(field.type)) {
      hasDateFields = true;
    }

    if (mapping.hasOptions && field.options) {
      // オプションを持つフィールド
      const options = Object.keys(field.options);
      const optionsStr = options.map((opt) => `'${opt}'`).join(', ');
      fieldDefinitions.push(
        `  ${code}: ${mapping.factory}('${code}', [${optionsStr}] as const)`
      );
    } else {
      // 通常のフィールド
      fieldDefinitions.push(`  ${code}: ${mapping.factory}('${code}')`);
    }
  });

  // コンポーネントの全体的な構造（改善版）
  const content = `/**
 * Query builder for ${appName}
 * Auto-generated by kintone-as-code
 * @generated ${new Date().toISOString()}
 */

import {
  ${Array.from(imports).sort().join(',\n  ')},
  // FP Query Builder
  createQueryState,
  setWhere,
  appendOrder,
  withLimit,
  withOffset,
  build,
  and,
  or,
  not${hasDateFields ? ',\n  // Date functions\n  TODAY,\n  FROM_TODAY,\n  THIS_WEEK,\n  THIS_MONTH,\n  THIS_YEAR' : ''},
  type ValidationOptions,
  type Expression
} from 'kintone-as-code';

${warnings.length > 0 ? warnings.join('\n') + '\n\n' : ''}/**
 * Type-safe field definitions for ${appName}
 */
export const QueryFields = {
${fieldDefinitions.join(',\n')}
} as const;

/**
 * Create a new query builder instance
 * @example
 * const query = createQuery()
 *   .where(QueryFields.status.equals('active'))
 *   .orderBy('createdAt', 'desc')
 *   .limit(100)
 *   .build();
 */
const makeBuilder = (state: ReturnType<typeof createQueryState>) => ({
  where(expr: Expression) {
    return makeBuilder(setWhere(expr)(state));
  },
  orderBy(field: string, direction: 'asc' | 'desc' = 'asc') {
    return makeBuilder(appendOrder(field, direction)(state));
  },
  limit(n: number) {
    return makeBuilder(withLimit(n)(state));
  },
  offset(n: number) {
    return makeBuilder(withOffset(n)(state));
  },
  setValidationOptions(opts: ValidationOptions) {
    // Note: optional chaining since opts fields are optional
    return makeBuilder((s => (opts ? { ...s, validationOptions: opts } : s))(state));
  },
  build() {
    return build(state);
  }
});

export const createQuery = () => makeBuilder(createQueryState());

// Export types for TypeScript support
export type FieldNames = keyof typeof QueryFields;
export type AppQueryFields = typeof QueryFields;
`;

  return content;
};
