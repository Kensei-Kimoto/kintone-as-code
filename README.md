# kintone-as-code

[![npm version](https://badge.fury.io/js/kintone-as-code.svg)](https://badge.fury.io/js/kintone-as-code)
[![CI](https://github.com/kimotokensei/kintone-as-code/actions/workflows/ci.yml/badge.svg)](https://github.com/kimotokensei/kintone-as-code/actions/workflows/ci.yml)
[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)

[æ—¥æœ¬èª](README.ja.md)

Manage kintone app configurations as code with type safety using Effect-TS.

## Architecture (Summary)

- Functional Core, Imperative Shell
- Core (pure functions in `src/query/*`): expressions, fields, FP builder, validation
- Shell (side effects): CLI/commands and code generator
- OO method-chaining facade remains for compatibility; internally backed by FP core

## Features

- ğŸ”’ **Type-safe** - Full TypeScript support with kintone-effect-schema
- ğŸ“ **Export from kintone** - Generate schema files from existing apps
- ğŸš€ **Apply changes** - Update existing apps with schema changes and automatically add new fields
- âœ¨ **Create apps** - Create new kintone apps from schema definitions
- ğŸ”§ **Environment management** - Support multiple kintone environments
- ğŸ¯ **Effect-TS powered** - Leverage the power of Effect-TS for schema validation
- ğŸ“‹ **Record Schema Generation** - Generates static, copy-paste-friendly record schemas for customization

## Installation

```bash
npm install -g kintone-as-code
```

## Prerequisites

- Node.js 18 or higher
- kintone environment with API access

## Quick Start

### 1. Initialize project

```bash
kintone-as-code init
```

This creates a `kintone-as-code.config.js` file with your environment settings.

### 2. Export an existing app

```bash
kintone-as-code export --app-id 123 --name customer-app
```

This generates:

- `apps/customer-app.schema.ts` - Fully typed field definitions
- `apps/customer-app.record-schema.ts` - Static, type-safe record validation schema (copy-paste friendly)
- `apps/customer-app.query.ts` - Type-safe query builder for kintone API (generated by default)

### 3. Apply changes to existing app

```bash
kintone-as-code apply --app-id 123 --schema apps/customer-app.schema.ts
```

This updates the app with any schema changes and automatically adds new fields.

### 4. Create a new app from schema

```bash
kintone-as-code create --schema apps/customer-app.schema.ts --name "Customer App Copy"
```

This creates a new app with all fields defined in the schema.

### 5. Define app schema

The exported schema uses kintone-effect-schema for complete type safety:

```typescript
import { defineAppSchema, getAppId } from 'kintone-as-code';
import type {
  SingleLineTextFieldProperties,
  NumberFieldProperties,
  SubtableFieldProperties,
} from 'kintone-effect-schema';

// Individual field definitions with complete type information
export const companyNameField: SingleLineTextFieldProperties = {
  type: 'SINGLE_LINE_TEXT',
  code: 'ä¼šç¤¾å',
  label: 'ä¼šç¤¾å',
  required: true,
  unique: true,
  maxLength: '100',
};

export const revenueField: NumberFieldProperties = {
  type: 'NUMBER',
  code: 'å£²ä¸Šé«˜',
  label: 'å¹´é–“å£²ä¸Šé«˜',
  unit: 'å††',
  unitPosition: 'AFTER',
};

// Subtable with nested fields
export const productsField: SubtableFieldProperties = {
  type: 'SUBTABLE',
  code: 'products',
  fields: {
    productName: {
      type: 'SINGLE_LINE_TEXT',
      code: 'productName',
      label: 'å•†å“å',
      required: true,
    },
    price: {
      type: 'NUMBER',
      code: 'price',
      label: 'å˜ä¾¡',
      unit: 'å††',
    },
  },
};

// App fields configuration
export const appFieldsConfig = {
  properties: {
    ä¼šç¤¾å: companyNameField,
    å£²ä¸Šé«˜: revenueField,
    products: productsField,
  },
};

// App schema definition
export default defineAppSchema({
  appId: getAppId('KINTONE_CUSTOMER_APP_ID'),
  name: 'Customer Management',
  description: 'Customer information management app',
  fieldsConfig: appFieldsConfig,
});
```

## Configuration

### Environment Variables

Set your app IDs as environment variables:

```bash
KINTONE_CUSTOMER_APP_ID=123
KINTONE_PRODUCT_APP_ID=456
```

### Configuration File

`kintone-as-code.config.js`:

```javascript
export default {
  default: 'production',
  environments: {
    production: {
      auth: {
        baseUrl: process.env.KINTONE_BASE_URL,
        username: process.env.KINTONE_USERNAME,
        password: process.env.KINTONE_PASSWORD,
      },
    },
    development: {
      auth: {
        baseUrl: process.env.KINTONE_BASE_URL,
        username: process.env.KINTONE_USERNAME,
        password: process.env.KINTONE_PASSWORD,
      },
    },
  },
};
```

## Integration with kintone-effect-schema

This tool is designed to work seamlessly with [kintone-effect-schema](https://github.com/Kensei-Kimoto/kintone-effect-schema), which provides:

- Complete type definitions for all kintone field types
- Runtime validation using Effect-TS
- Support for Japanese field codes
- Automatic handling of empty values

## Commands

### init

Initialize a new kintone-as-code project:

```bash
kintone-as-code init [options]

Options:
  -f, --force  Force overwrite existing files
```

### export

Export kintone app configuration to TypeScript:

```bash
kintone-as-code export [options]

Options:
  --app-id <id>             App ID to export (required)
  --name <name>             Schema file name (required)
  --env <env>               Environment name
  --output <dir>            Output directory (default: "apps")
  --with-record-schema      Generate record schema file (default: true)
  --no-record-schema        Skip record schema generation
  --with-query              Generate query builder file (default: true)
  --no-query                Skip query builder generation
```

The export command now generates three files by default:

1. **Field Schema** (`{name}.schema.ts`) - Field definitions and configurations
2. **Record Schema** (`{name}.record-schema.ts`) - Type-safe record validation with Effect Schema
3. **Query Builder** (`{name}.query.ts`) - Type-safe query builder for kintone REST API

### apply

Apply schema changes to an existing kintone app:

```bash
kintone-as-code apply [options]

Options:
  --app-id <id>    App ID to update (optional; if omitted, uses appId from schema)
  --schema <path>  Path to schema file (required)
  --env <env>      Environment name
```

Features:

- Updates existing fields with type-safe validation
- Automatically detects and adds new fields
- Deploys changes after successful update

### create

Create a new kintone app from a schema file:

```bash
kintone-as-code create [options]

Options:
  --schema <path>   Path to schema file (required)
  --name <name>     Override app name from schema
  --space <id>      Create app in specific space
  --thread <id>     Thread ID in the space (when creating inside a space)
  --env <env>       Environment name
```

Features:

- Creates new app with all fields defined in schema
- Supports creating apps in specific spaces
- Automatically deploys the app after creation

## Record Schema Usage

The generated record schema provides type-safe validation for kintone records with automatic normalization:

```typescript
import { KintoneRestAPIClient } from '@kintone/rest-api-client';
import {
  validateRecord,
  type AppRecord,
} from './apps/customer-app.record-schema';

// Initialize client
const client = new KintoneRestAPIClient({
  baseUrl: 'https://example.cybozu.com',
  auth: { apiToken: 'YOUR_API_TOKEN' },
});

// Fetch and validate record with automatic normalization
const response = await client.record.getRecord({
  app: 123,
  id: 1,
});
const validatedRecord: AppRecord = validateRecord(response.record);
// validatedRecord is fully typed and normalized (no type assertions needed)
// Empty strings in number fields â†’ null, undefined â†’ '', etc.
```

### Example of generated Record Schema (simple)

```ts
import { Schema } from 'effect';
import {
  SingleLineTextFieldSchema,
  NumberFieldSchema,
  decodeKintoneRecord,
} from 'kintone-effect-schema';

// Static output example
export const RecordSchema = Schema.Struct({
  title: SingleLineTextFieldSchema,
  amount: NumberFieldSchema,
});

export type AppRecord = Schema.Schema.Type<typeof RecordSchema>;

export const validateRecord = (record: Record<string, unknown>): AppRecord => {
  const normalized = decodeKintoneRecord(record);
  return Schema.decodeUnknownSync(RecordSchema)(normalized);
};
```

### JavaScript API Usage (Customization)

```typescript
import {
  validateRecord,
  type AppRecord,
} from './apps/customer-app.record-schema';

kintone.events.on('app.record.detail.show', (event) => {
  // Same function works for JavaScript API
  const validatedRecord: AppRecord = validateRecord(event.record);
  // Handles all empty value inconsistencies automatically
  return event;
});
```

## Query Builder Usage

The generated query builder provides type-safe query construction with IDE auto-completion:

```typescript
import { QueryFields, createQuery } from './apps/customer-app.query';
import { and, or } from 'kintone-as-code';

// All field names are auto-completed
const { ä¼šç¤¾å, ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹, å£²ä¸Šé«˜, æ‹…å½“è€… } = QueryFields;

// Build type-safe queries
// OO facade (method-chain)
const query = createQuery()
  .where(
    and(
      ä¼šç¤¾å.like('*ã‚µã‚¤ãƒœã‚¦ã‚º*'),
      å£²ä¸Šé«˜.greaterThan(1000000),
      ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹.in(['å•†è«‡ä¸­', 'å—æ³¨'])
    )
  )
  .orderBy('å£²ä¸Šé«˜', 'desc')
  .limit(100)
  .build();

// Use with kintone REST API
const client = new KintoneRestAPIClient({
  /* ... */
});

// Functional API (pure functions)
import {
  createQueryState,
  setWhere,
  appendOrder,
  withLimit,
  build,
} from 'kintone-as-code/query';

const query2 = build(
  withLimit(100)(
    appendOrder(
      'å£²ä¸Šé«˜',
      'desc'
    )(
      setWhere(
        and(
          ä¼šç¤¾å.like('*ã‚µã‚¤ãƒœã‚¦ã‚º*'),
          å£²ä¸Šé«˜.greaterThan(1000000),
          ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹.in(['å•†è«‡ä¸­', 'å—æ³¨'])
        )
      )(createQueryState())
    )
  )
);
const records = await client.record.getRecords({
  app: 123,
  query: query,
});
```

### Query Features

- **Type-safe field access**: All fields are typed based on their kintone field types
- **Field-specific operators**: Only valid operators for each field type are available
- **kintone functions**: Support for `TODAY()`, `LOGINUSER()`, `THIS_MONTH()`, etc.
- **Complex conditions**: Combine with `and()`, `or()`, `not()`
- **Auto-completion**: IDE provides suggestions for fields and methods

### Field Type Examples

```typescript
// String fields support like/not like
ä¼šç¤¾å.like('*æ ªå¼ä¼šç¤¾*');
ä¼šç¤¾å.notLike('*test*');

// Number fields support comparison operators
å£²ä¸Šé«˜.greaterThan(1000000);
å£²ä¸Šé«˜.lessThanOrEqual(5000000);

// Dropdown fields use in/not in
ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹.in(['å•†è«‡ä¸­', 'å—æ³¨']);
ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹.notIn(['å¤±æ³¨', 'ã‚­ãƒ£ãƒ³ã‚»ãƒ«']);

// Date fields support date functions
å¥‘ç´„æ—¥.equals(TODAY());
æœŸé™æ—¥.lessThan(FROM_TODAY(7, 'DAYS'));
ç™»éŒ²æ—¥.in([THIS_MONTH()]);

// User fields support user functions
æ‹…å½“è€….equals(LOGINUSER());
ä½œæˆè€….in(['user1', 'user2']);
```

## Best Practices

1. **Version Control**: Commit your schema files to track app configuration changes
2. **Environment Variables**: Use environment variables for app IDs to support multiple environments
3. **Type Safety**: Leverage TypeScript's type checking to catch configuration errors early
4. **Code Review**: Review schema changes as part of your development process
5. **Record Validation**: Use generated record schemas in your customization code for type-safe data handling

## License

MIT
