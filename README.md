# kintone-as-code

[![npm version](https://badge.fury.io/js/kintone-as-code.svg)](https://badge.fury.io/js/kintone-as-code)
[![CI](https://github.com/kimotokensei/kintone-as-code/actions/workflows/ci.yml/badge.svg)](https://github.com/kimotokensei/kintone-as-code/actions/workflows/ci.yml)
[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)

[Êó•Êú¨Ë™û](README.ja.md)

Manage kintone app configurations as code with type safety using Effect-TS.

## Architecture (Summary)

- Functional Core, Imperative Shell
- Core (pure functions in `src/query/*`): expressions, fields, FP builder, validation
- Shell (side effects): CLI/commands and code generator
- Public API is FP-only. No OO facade is provided. The method-chaining `createQuery()` is a helper emitted in generated files `apps/{name}.query.ts`, not a public package API.

## Features

- üîí **Type-safe** - Full TypeScript support with kintone-effect-schema
- üìù **Export from kintone** - Generate schema files from existing apps
- üöÄ **Apply changes** - Update existing apps with schema changes and automatically add new fields
- ‚ú® **Create apps** - Create new kintone apps from schema definitions
- üîß **Environment management** - Support multiple kintone environments
- üéØ **Effect-TS powered** - Leverage the power of Effect-TS for schema validation
- üìã **Record Schema Generation** - Generates static, copy-paste-friendly record schemas for customization

## Installation

```bash
npm install -g kintone-as-code
```

## Prerequisites

- Node.js 18 or higher
- kintone environment with API access

## Quick Start

### 1. Initialize project

```bash
kintone-as-code init
```

This creates a `kintone-as-code.config.js` file with your environment settings.

### 2. Export an existing app

```bash
# Default: generates query and record-schema as well
kintone-as-code export --app-id 123 --name customer-app

# Suppress generation (backward-compatible --with-* also supported)
kintone-as-code export --app-id 123 --name customer-app --no-query
kintone-as-code export --app-id 123 --name customer-app --no-record-schema

# Include related/subtable fields as dot-notation (minimal: in/not in only)
kintone-as-code export --app-id 123 --name customer-app \
  --include-related \
  --include-subtable
```

This generates:

- `apps/customer-app.schema.ts` - Fully typed field definitions
- `apps/customer-app.record-schema.ts` - Static, type-safe record validation schema (copy-paste friendly)
- `apps/customer-app.query.ts` - Type-safe query builder for kintone API (generated by default)
  - With `--include-related`, `REFERENCE_TABLE` displayFields are exposed minimally via `createTableSubField('parent.child')` (in/not in only)
  - With `--include-subtable`, subtable child fields are exposed with the same minimal API

### 3. Apply changes to existing app

```bash
kintone-as-code apply --app-id 123 --schema apps/customer-app.schema.ts
```

This updates the app with any schema changes and automatically adds new fields.

### 4. Create a new app from schema

```bash
kintone-as-code create --schema apps/customer-app.schema.ts --name "Customer App Copy"
```

This creates a new app with all fields defined in the schema.

### 5. Define app schema

The exported schema uses kintone-effect-schema for complete type safety:

```typescript
import { defineAppSchema, getAppId } from 'kintone-as-code';
import type {
  SingleLineTextFieldProperties,
  NumberFieldProperties,
  SubtableFieldProperties,
} from 'kintone-effect-schema';

// Individual field definitions with complete type information
export const companyNameField: SingleLineTextFieldProperties = {
  type: 'SINGLE_LINE_TEXT',
  code: '‰ºöÁ§æÂêç',
  label: '‰ºöÁ§æÂêç',
  required: true,
  unique: true,
  maxLength: '100',
};

export const revenueField: NumberFieldProperties = {
  type: 'NUMBER',
  code: 'Â£≤‰∏äÈ´ò',
  label: 'Âπ¥ÈñìÂ£≤‰∏äÈ´ò',
  unit: 'ÂÜÜ',
  unitPosition: 'AFTER',
};

// Subtable with nested fields
export const productsField: SubtableFieldProperties = {
  type: 'SUBTABLE',
  code: 'products',
  fields: {
    productName: {
      type: 'SINGLE_LINE_TEXT',
      code: 'productName',
      label: 'ÂïÜÂìÅÂêç',
      required: true,
    },
    price: {
      type: 'NUMBER',
      code: 'price',
      label: 'Âçò‰æ°',
      unit: 'ÂÜÜ',
    },
  },
};

// App fields configuration
export const appFieldsConfig = {
  properties: {
    ‰ºöÁ§æÂêç: companyNameField,
    Â£≤‰∏äÈ´ò: revenueField,
    products: productsField,
  },
};

// App schema definition
export default defineAppSchema({
  appId: getAppId('KINTONE_CUSTOMER_APP_ID'),
  name: 'Customer Management',
  description: 'Customer information management app',
  fieldsConfig: appFieldsConfig,
});
```

## Configuration

### Environment Variables

Set your app IDs as environment variables:

```bash
KINTONE_CUSTOMER_APP_ID=123
KINTONE_PRODUCT_APP_ID=456
```

### Configuration File

`kintone-as-code.config.js`:

```javascript
export default {
  default: 'production',
  environments: {
    production: {
      auth: {
        baseUrl: process.env.KINTONE_BASE_URL,
        username: process.env.KINTONE_USERNAME,
        password: process.env.KINTONE_PASSWORD,
      },
    },
    development: {
      auth: {
        baseUrl: process.env.KINTONE_BASE_URL,
        username: process.env.KINTONE_USERNAME,
        password: process.env.KINTONE_PASSWORD,
      },
    },
  },
};
```

## Integration with kintone-effect-schema

This tool is designed to work seamlessly with [kintone-effect-schema](https://github.com/Kensei-Kimoto/kintone-effect-schema), which provides:

- Complete type definitions for all kintone field types
- Runtime validation using Effect-TS
- Support for Japanese field codes
- Automatic handling of empty values

## Commands

### Docs index

- Overview (IaC): `docs/overview.ja.md`
- Config: `docs/config.ja.md`
- Converter & Schemas: `docs/converter-and-schemas.ja.md`
- Export/Apply/Create: `docs/export-apply-create.ja.md`
- Query Builder: `docs/query-builder.ja.md`
- Query Cookbook: `docs/query-cookbook.ja.md`
- Architecture: `docs/architecture.ja.md`

### init

Initialize a new kintone-as-code project:

```bash
kintone-as-code init [options]

Options:
  -f, --force  Force overwrite existing files
```

### export

Export kintone app configuration to TypeScript:

```bash
kintone-as-code export [options]

Options:
  --app-id <id>             App ID to export (required)
  --name <name>             Schema file name (required)
  --env <env>               Environment name
  --output <dir>            Output directory (default: "apps")
  --with-record-schema      Generate record schema file (default: true)
  --no-record-schema        Skip record schema generation
  --with-query              Generate query builder file (default: true)
  --no-query                Skip query builder generation
```

The export command now generates three files by default:

1. **Field Schema** (`{name}.schema.ts`) - Field definitions and configurations
2. **Record Schema** (`{name}.record-schema.ts`) - Type-safe record validation with Effect Schema
3. **Query Builder** (`{name}.query.ts`) - Type-safe query builder for kintone REST API

### apply

Apply schema changes to an existing kintone app:

```bash
kintone-as-code apply [options]

Options:
  --app-id <id>    App ID to update (optional; if omitted, uses appId from schema)
  --schema <path>  Path to schema file (required)
  --env <env>      Environment name
```

Features:

- Updates existing fields with type-safe validation
- Automatically detects and adds new fields
- Deploys changes after successful update

### create

Create a new kintone app from a schema file:

```bash
kintone-as-code create [options]

Options:
  --schema <path>   Path to schema file (required)
  --name <name>     Override app name from schema
  --space <id>      Create app in specific space
  --thread <id>     Thread ID in the space (when creating inside a space)
  --env <env>       Environment name
```

Features:

- Creates new app with all fields defined in schema
- Supports creating apps in specific spaces
- Automatically deploys the app after creation

## Record Schema Usage

The generated record schema provides type-safe validation for kintone records with automatic normalization:

```typescript
import { KintoneRestAPIClient } from '@kintone/rest-api-client';
import {
  validateRecord,
  type AppRecord,
} from './apps/customer-app.record-schema';

// Initialize client
const client = new KintoneRestAPIClient({
  baseUrl: process.env.KINTONE_BASE_URL!,
  auth: { username: process.env.KINTONE_USERNAME!, password: process.env.KINTONE_PASSWORD! },
});

// Fetch and validate record with automatic normalization
const response = await client.record.getRecord({
  app: 123,
  id: 1,
});
const validatedRecord: AppRecord = validateRecord(response.record);
// validatedRecord is fully typed and normalized (no type assertions needed)
// Empty strings in number fields ‚Üí null, undefined ‚Üí '', etc.
```

### Example of generated Record Schema (simple)

```ts
import { Schema } from 'effect';
import {
  SingleLineTextFieldSchema,
  NumberFieldSchema,
  decodeKintoneRecord,
} from 'kintone-effect-schema';

// Static output example
export const RecordSchema = Schema.Struct({
  title: SingleLineTextFieldSchema,
  amount: NumberFieldSchema,
});

export type AppRecord = Schema.Schema.Type<typeof RecordSchema>;

export const validateRecord = (record: Record<string, unknown>): AppRecord => {
  const normalized = decodeKintoneRecord(record);
  return Schema.decodeUnknownSync(RecordSchema)(normalized);
};
```

### JavaScript API Usage (Customization)

```typescript
import {
  validateRecord,
  type AppRecord,
} from './apps/customer-app.record-schema';

kintone.events.on('app.record.detail.show', (event) => {
  // Same function works for JavaScript API
  const validatedRecord: AppRecord = validateRecord(event.record);
  // Handles all empty value inconsistencies automatically
  return event;
});
```

## Query Builder Usage

The generated query builder provides type-safe query construction with IDE auto-completion:

```typescript
import { QueryFields, createQuery } from './apps/customer-app.query';
import { and, or } from 'kintone-as-code';

// All field names are auto-completed
const { ‰ºöÁ§æÂêç, „Çπ„ÉÜ„Éº„Çø„Çπ, Â£≤‰∏äÈ´ò, ÊãÖÂΩìËÄÖ } = QueryFields;

// Build type-safe queries
// OO facade (method-chain)
const query = createQuery()
  .where(
    and(
      ‰ºöÁ§æÂêç.like('*„Çµ„Ç§„Éú„Ç¶„Ç∫*'),
      Â£≤‰∏äÈ´ò.greaterThan(1000000),
      „Çπ„ÉÜ„Éº„Çø„Çπ.in(['ÂïÜË´á‰∏≠', 'ÂèóÊ≥®'])
    )
  )
  .orderBy('Â£≤‰∏äÈ´ò', 'desc')
  .limit(100)
  .build();

// Use with kintone REST API
const client = new KintoneRestAPIClient({
  /* ... */
});

// Functional API (pure functions)
import {
  createQueryState,
  setWhere,
  appendOrder,
  withLimit,
  build,
} from 'kintone-as-code';

const query2 = build(
  withLimit(100)(
    appendOrder(
      'Â£≤‰∏äÈ´ò',
      'desc'
    )(
      setWhere(
        and(
          ‰ºöÁ§æÂêç.like('*„Çµ„Ç§„Éú„Ç¶„Ç∫*'),
          Â£≤‰∏äÈ´ò.greaterThan(1000000),
          „Çπ„ÉÜ„Éº„Çø„Çπ.in(['ÂïÜË´á‰∏≠', 'ÂèóÊ≥®'])
        )
      )(createQueryState())
    )
  )
);
const records = await client.record.getRecords({
  app: 123,
  query: query,
});
```

#### Helper methods

- Strings: `contains()/startsWith()/endsWith()`
- Numbers/Date/DateTime/Time: `between(min, max)`
- Functions (unsupported names): `customDateFunction(name, ...args)` / `customUserFunction(name, ...args)`

### Query Features

- **Type-safe field access**: All fields are typed based on their kintone field types
- **Field-specific operators**: Only valid operators for each field type are available
- **kintone functions**: Support for `TODAY()`, `LOGINUSER()`, `THIS_MONTH()`, etc.
- **Complex conditions**: Combine with `and()`, `or()`, `not()`
- **Auto-completion**: IDE provides suggestions for fields and methods

Note: The query builder is not exposed as a public API. Internally we follow FP design; if we expose it in the future, the FP API will be the only supported style.

### Note: No `raw()` escape hatch

Direct raw query insertion via `raw()` is not provided. Instead, use
`contains/startsWith/endsWith`, `between(min, max)`, and
`customDateFunction/customUserFunction` as escape hatches.

### Field Type Examples

```typescript
// String fields support like/not like
‰ºöÁ§æÂêç.like('*Ê†™Âºè‰ºöÁ§æ*');
‰ºöÁ§æÂêç.notLike('*test*');

// Number fields support comparison operators
Â£≤‰∏äÈ´ò.greaterThan(1000000);
Â£≤‰∏äÈ´ò.lessThanOrEqual(5000000);

// Dropdown fields use in/not in
„Çπ„ÉÜ„Éº„Çø„Çπ.in(['ÂïÜË´á‰∏≠', 'ÂèóÊ≥®']);
„Çπ„ÉÜ„Éº„Çø„Çπ.notIn(['Â§±Ê≥®', '„Ç≠„É£„É≥„Çª„É´']);

// Date fields support date functions
Â•ëÁ¥ÑÊó•.equals(TODAY());
ÊúüÈôêÊó•.lessThan(FROM_TODAY(7, 'DAYS'));
ÁôªÈå≤Êó•.in([THIS_MONTH()]);

// User fields support user functions
ÊãÖÂΩìËÄÖ.equals(LOGINUSER());
‰ΩúÊàêËÄÖ.in(['user1', 'user2']);
```

## Best Practices

1. **Version Control**: Commit your schema files to track app configuration changes
2. **Environment Variables**: Use environment variables for app IDs to support multiple environments
3. **Type Safety**: Leverage TypeScript's type checking to catch configuration errors early
4. **Code Review**: Review schema changes as part of your development process
5. **Record Validation**: Use generated record schemas in your customization code for type-safe data handling

## License

MIT
